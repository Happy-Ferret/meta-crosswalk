Upstream-Status: Backport

[this is actually patch for the v8 git repository]

Signed-off-by: Raphael Kubo da Costa <raphael.kubo.da.costa@intel.com>
---
From 682a41db33afada6052997f8d2ee5f20c3069787 Mon Sep 17 00:00:00 2001
From: dpranke <dpranke@chromium.org>
Date: Mon, 25 Jul 2016 02:29:17 -0700
Subject: [PATCH] Attempt #4 to land "Fix double-building of v8 in GN builds."

The third attempt never landed :). This attempt completely reworks
the logic to attempt to be clearer and more obviously correct. This
attempt also actually had unit tests written for it (see bug 625353).

R=machenbach@chromium.org
BUG=625353, 629825
CQ_INCLUDE_TRYBOTS=master.tryserver.chromium.android:android_compile_x86_dbg,android_compile_mips_dbg,android_arm64_dbg_recipe

Review-Url: https://codereview.chromium.org/2173343002
Cr-Commit-Position: refs/heads/master@{#37999}
---
 snapshot_toolchain.gni | 84 ++++++++++++++++++++++++++++++++++----------------
 1 file changed, 58 insertions(+), 26 deletions(-)

diff --git a/v8/snapshot_toolchain.gni b/v8/snapshot_toolchain.gni
index 5fe19fd..a03e35a 100644
--- a/v8/snapshot_toolchain.gni
+++ b/v8/snapshot_toolchain.gni
@@ -28,42 +28,74 @@
 import("//build/config/v8_target_cpu.gni")
 
 declare_args() {
-  # The snapshot needs to be compiled for the host, but compiled with
-  # a toolchain that matches the bit-width of the target.
+  # The v8 snapshot needs to be built by code that is compiled with a
+  # toolchain that matches the bit-width of the target CPU, but runs on
+  # the host.
   v8_snapshot_toolchain = ""
 }
 
-# TODO(GYP): For now we only support 32-bit little-endian target builds from an
-# x64 Linux host. Eventually we need to support all of the host/target
-# configurations v8 runs on.
+# Try to infer the appropriate snapshot toolchain for the v8_current_cpu
+# where possible.
+#
+# Assume that v8_target_cpu (and hence v8_current_cpu) has been validated
+# as supported on the current host CPU and OS in v8_target_cpu.gni. The
+# logic below is complicated enough without also needing to do input
+# validation.
+#
+# There are test cases for this code posted as an attachment to
+# https://crbug.com/625353.
+#
+# TODO(GYP): Currently only regular (non-cross) compiles, and cross-compiles
+# from x64 hosts to Intel, ARM, or MIPS targets, are implemented. Add support
+# for the other supported configurations.
+
 if (v8_snapshot_toolchain == "") {
-  if (host_cpu == "x64" && host_os == "linux") {
-    if (current_cpu == "arm" || current_cpu == "mipsel" ||
-        current_cpu == "x86") {
-      _snapshot_cpu = "x86"
+
+  if (current_os == host_os && current_cpu == host_cpu) {
+    # This is not a cross-compile, so build the snapshot with the current
+    # toolchain.
+    v8_snapshot_toolchain = current_toolchain
+
+  } else if (current_os == host_os && current_cpu == "x86" &&
+             host_cpu == "x64") {
+    # This is an x64 -> x86 cross-compile, but x64 hosts can usually run x86
+    # binaries built for the same OS, so build the snapshot with the current
+    # toolchain here, too.
+    v8_snapshot_toolchain = current_toolchain
+
+  } else if (current_os == "win" && host_os == "mac" && is_clang) {
+    # This is a mac -> win cross-compile, which is only supported w/ clang.
+    v8_snapshot_toolchain = "//build/toolchain/mac:clang_${v8_current_cpu}"
+
+  } else if (host_cpu == "x64") {
+    # This is a cross-compile from an x64 host to either a non-Intel target
+    # cpu or a different target OS. Assume the same toolchain (Clang or GCC
+    # or MSVS) for target and host, unless this is an Android build, where
+    # Clang is always used on the host.
+    if (is_clang || is_android) {
+      _clang = "clang_"
     } else {
-      assert(current_cpu == "arm64" || current_cpu == "x64" ||
-                 current_cpu == "mipsel64",
-             "Need environment for this arch: $current_cpu")
-      _snapshot_cpu = "x64"
+      _clang = ""
     }
 
-    if (v8_current_cpu != _snapshot_cpu) {
-      _cpus = "${_snapshot_cpu}_v8_${v8_current_cpu}"
+    if (v8_current_cpu == "x64" || v8_current_cpu == "x86") {
+      _cpus = v8_current_cpu
+    } else if (v8_current_cpu == "arm64" || v8_current_cpu == "mips64el") {
+      _cpus = "x64_v8_${v8_current_cpu}"
+    } else if (v8_current_cpu == "arm" || v8_current_cpu == "mipsel") {
+      _cpus = "x86_v8_${v8_current_cpu}"
     } else {
-      _cpus = _snapshot_cpu
+      # This branch should not be reached; leave _cpus blank so the assert
+      # below will fail.
+      _cpus = ""
     }
 
-    if ((host_os == "linux" && current_os == "android") || is_clang) {
-      v8_snapshot_toolchain = "//build/toolchain/linux:clang_${_cpus}"
-    } else {
-      v8_snapshot_toolchain = "//build/toolchain/linux:${_cpus}"
+    if (_cpus != "") {
+      v8_snapshot_toolchain = "//build/toolchain/${host_os}:${_clang}${_cpus}"
     }
-  } else if (host_os == "mac" && current_os == "win") {
-    assert(v8_current_cpu == current_cpu,
-           "v8 target must match the regular target on this platform")
-    v8_snapshot_toolchain = "//build/toolchain/mac:clang_$current_cpu"
-  } else {
-    v8_snapshot_toolchain = default_toolchain
   }
 }
+
+assert(v8_snapshot_toolchain != "",
+       "Do not know how to build a snapshot for $current_toolchain " +
+       "on $host_os $host_cpu")
-- 
2.7.4

